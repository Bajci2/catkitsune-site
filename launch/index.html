<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>CatKitSune - Mint NFT</title>

<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800;900&display=swap" rel="stylesheet">
<script src="https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.umd.min.js"></script>

<style>
*{box-sizing:border-box;margin:0;padding:0}

:root{
  --primary:#14b8a6;
  --primary-dark:#0d9488;
  --bg-main:#f0fdf9;
  --border:#e5e7eb;
  --purple:#8b5cf6;
  --purple-dark:#7c3aed;
}

body{
  font-family:Inter,sans-serif;
  background:linear-gradient(135deg,#f0fdf9 0%,#ccfbf1 100%);
  min-height:100vh;
  color:#111827;
  padding-bottom:60px;
}

.container{
  max-width:1400px;
  margin:0 auto;
  padding:20px
}

/* HEADER */
header{
  background:linear-gradient(135deg,#f0fdf9 0%,#ccfbf1 100%);
  border-bottom:1px solid var(--border);
  padding:24px 0;
  position:sticky;
  top:0;
  z-index:100
}

.header-content{
  max-width:1400px;
  margin:0 auto;
  padding:0 20px;
  display:flex;
  justify-content:space-between;
  align-items:center
}

/* LOGO */
.logo{
  display:flex;
  align-items:center;
  text-decoration:none
}

.logo-img{
  height:88px;
  width:auto;
  display:block
}

/* BACK BUTTON */
.back-btn{
  padding:12px 22px;
  background:var(--primary);
  color:#fff;
  border-radius:14px;
  text-decoration:none;
  font-weight:700;
  transition:.3s
}
.back-btn:hover{
  opacity:.9;
  transform:translateY(-2px)
}

/* SUPPLY BANNER */
.supply-banner{
  background:linear-gradient(135deg,#667eea,#764ba2);
  padding:24px 32px;
  border-radius:20px;
  display:flex;
  justify-content:space-between;
  align-items:center;
  margin-bottom:32px
}

.supply-banner.free-mint-banner{
  background:linear-gradient(135deg,#8b5cf6,#7c3aed);
}

.supply-count{
  font-size:36px;
  font-weight:900;
  color:#fff
}
.progress-container{flex:1;margin:0 32px}
.progress-bar{
  height:14px;
  background:rgba(255,255,255,.2);
  border-radius:999px;
  overflow:hidden
}
.progress-fill{
  height:100%;
  background:linear-gradient(90deg,#10b981,#22c55e);
  width:0%;
  transition:width 0.5s ease
}
.progress-text{
  color:#fff;
  font-size:13px;
  text-align:center;
  margin-top:8px;
  font-weight:600
}
.status-badge{
  background:rgba(255,255,255,.25);
  padding:12px 24px;
  border-radius:999px;
  color:#fff;
  font-weight:700
}

/* LAYOUT */
.mint-section{
  display:grid;
  grid-template-columns:1fr 1fr;
  gap:32px;
  margin-bottom:48px;
}
@media(max-width:1024px){
  .mint-section{grid-template-columns:1fr}
}

.nft-preview,.mint-card{
  background:#fff;
  border-radius:24px;
  padding:32px;
  box-shadow:0 10px 40px rgba(0,0,0,.08)
}

/* NFT GRID */
.nft-grid-container{
  display:grid;
  grid-template-columns:repeat(3,1fr);
  gap:16px
}
.nft-grid-container img{
  width:100%;
  aspect-ratio:1/1;
  object-fit:cover;
  border-radius:16px
}

/* MINT CARD */
.mint-card h1{font-size:32px;margin-bottom:8px}
.mint-card h2{
  font-size:36px;
  font-weight:900;
  color:var(--primary);
  margin-bottom:24px
}

.mint-card.free-mint h2{
  color:var(--purple);
}

/* MINT BUTTON */
.mint-button{
  width:100%;
  padding:20px;
  background:linear-gradient(135deg,var(--primary),var(--primary-dark));
  color:#fff;
  border:none;
  border-radius:16px;
  font-size:18px;
  font-weight:700;
  cursor:pointer;
  transition:all 0.3s ease;
}

.mint-button.free-mint-btn{
  background:linear-gradient(135deg,var(--purple),var(--purple-dark));
}

.mint-button:hover{
  transform:translateY(-2px);
  box-shadow:0 8px 24px rgba(20,184,166,0.4);
}

.mint-button.free-mint-btn:hover{
  box-shadow:0 8px 24px rgba(139,92,246,0.4);
}

.mint-button:disabled{
  opacity:0.6;
  cursor:not-allowed;
  transform:none;
}

/* DEBUG */
.debug-info{
  margin-top:24px;
  padding:20px;
  background:#f9fafb;
  border-radius:16px;
  font-size:13px;
  font-family:monospace;
  max-height:400px;
  overflow:auto;
  border:2px solid #e5e7eb;
}

.debug-log{
  margin:6px 0;
  padding:8px 12px;
  border-left:4px solid #14b8a6;
  background:#fff;
  border-radius:4px;
}

.debug-error{
  border-left-color:#ef4444;
  background:#fef2f2;
  color:#dc2626;
  font-weight:600;
}

.debug-success{
  border-left-color:#10b981;
  background:#d1fae5;
  color:#059669;
  font-weight:600;
}

/* DIVIDER */
.section-divider{
  margin:48px 0;
  text-align:center;
  position:relative;
}

.section-divider::before{
  content:'';
  position:absolute;
  top:50%;
  left:0;
  right:0;
  height:2px;
  background:linear-gradient(90deg, transparent, #e5e7eb, transparent);
}

.section-divider span{
  background:#f0fdf9;
  padding:0 24px;
  position:relative;
  font-weight:700;
  color:#6b7280;
  font-size:14px;
  text-transform:uppercase;
  letter-spacing:1px;
}
</style>
</head>

<body>

<header>
  <div class="header-content">
    <a href="/" class="logo">
      <img src="https://kephost.net/p/MjI3NDg0NQ.png" alt="CatKitSune" class="logo-img">
    </a>
    <a class="back-btn" href="/">‚Üê Back</a>
  </div>
</header>

<div class="container">

<!-- ==================== PAID MINT SECTION ==================== -->
<div class="supply-banner">
  <div>
    <div style="color:#fff;opacity:.8;font-size:14px">Paid Minted</div>
    <div class="supply-count" id="supplyCount">‚Äî / 300</div>
  </div>
  <div class="progress-container">
    <div class="progress-bar">
      <div class="progress-fill" id="progressFill"></div>
    </div>
    <div class="progress-text" id="progressText">Loading‚Ä¶</div>
  </div>
  <div class="status-badge">üî• Minting Live</div>
</div>

<div class="mint-section">

<div class="nft-preview">
  <div class="nft-grid-container">
    <img src="/launch/1.png" alt="NFT 1">
    <img src="/launch/2.png" alt="NFT 2">
    <img src="/launch/3.png" alt="NFT 3">
    <img src="/launch/4.png" alt="NFT 4">
    <img src="/launch/5.png" alt="NFT 5">
    <img src="/launch/6.png" alt="NFT 6">
    <img src="/launch/7.png" alt="NFT 7">
    <img src="/launch/8.png" alt="NFT 8">
    <img src="/launch/9.png" alt="NFT 9">
  </div>
</div>

<div class="mint-card">
  <h1>üî• Mint Your NFT - CatKitSune</h1>
  <h2>0.1 HYPE</h2>
  <button class="mint-button" id="mintButton">Connect Wallet</button>
  <div class="debug-info" id="debugInfo">
    <div class="debug-log">Waiting for wallet connection...</div>
  </div>
</div>

</div>

<!-- ==================== DIVIDER ==================== -->
<div class="section-divider">
  <span>Free Mint Collection</span>
</div>

<!-- ==================== FREE MINT SECTION ==================== -->
<div class="supply-banner free-mint-banner">
  <div>
    <div style="color:#fff;opacity:.8;font-size:14px">Free Minted</div>
    <div class="supply-count" id="freeSupplyCount">‚Äî / 222</div>
  </div>
  <div class="progress-container">
    <div class="progress-bar">
      <div class="progress-fill" id="freeProgressFill"></div>
    </div>
    <div class="progress-text" id="freeProgressText">Loading‚Ä¶</div>
  </div>
  <div class="status-badge">üéÅ Free Mint Live</div>
</div>

<div class="mint-section">

<div class="nft-preview">
  <div class="nft-grid-container">
     <img src="/launch-free/1.png" alt="Free NFT 1">
    <img src="/launch-free/2.png" alt="Free NFT 2">
    <img src="/launch-free/3.png" alt="Free NFT 3">
    <img src="/launch-free/4.png" alt="Free NFT 4">
    <img src="/launch-free/5.png" alt="Free NFT 5">
    <img src="/launch-free/7.png" alt="Free NFT 7">
    <img src="/launch-free/8.png" alt="Free NFT 8">
    <img src="/launch-free/9.png" alt="Free NFT 9">
    <img src="/launch-free/10.png" alt="Free NFT 10">
  </div>
</div>

<div class="mint-card free-mint">
  <h1>üéÅ Free Mint - VeLoRa</h1>
  <h2>0 HYPE</h2>
  <button class="mint-button free-mint-btn" id="freeMintButton">Connect Wallet</button>
  <div class="debug-info" id="freeDebugInfo">
    <div class="debug-log">Waiting for wallet connection...</div>
  </div>
</div>

</div>

</div>

<script>
// ===========================
// HYPERLIQUID CONFIG
// ===========================
const HYPERLIQUID_CONFIG = {
  chainId: '0x3E7', // 999 decimal (MAINNET)
  chainName: 'Hyperliquid',
  rpcUrls: ['https://rpc.hyperliquid.xyz/evm'],
  nativeCurrency: {
    name: 'HYPE',
    symbol: 'HYPE',
    decimals: 18
  },
  blockExplorerUrls: ['https://hypurrscan.io']
};

// ===========================
// PAID MINT CONTRACT CONFIG
// ===========================
const CONTRACT_ADDRESS = '0x2abF2969E5e9cAAa1D3fF3DF4265dFFcda0D8353';
const CONTRACT_ABI = [
  'function mint() public payable',
  'function _tokenIdCounter() public view returns (uint256)',
  'function MAX_SUPPLY() public view returns (uint256)',
  'function balanceOf(address owner) public view returns (uint256)',
  'function owner() public view returns (address)',
  'function mintPrice() public view returns (uint256)'
];
const MINT_PRICE = ethers.utils.parseEther('0.1');
let currentMintedSupply = 27;
const MAX_SUPPLY = 300;

// ===========================
// FREE MINT CONTRACT CONFIG
// ===========================
const FREE_CONTRACT_ADDRESS = '0x568d76Cb80cAa08A2196467ed5cBdFBD4D74b1eE';
const FREE_CONTRACT_ABI = [
  'function mint() public payable',
  'function _tokenIdCounter() public view returns (uint256)',
  'function MAX_SUPPLY() public view returns (uint256)',
  'function balanceOf(address owner) public view returns (uint256)',
  'function maxPerWallet() public view returns (uint256)'
];
const FREE_MINT_PRICE = ethers.utils.parseEther('0');
let freeCurrentMintedSupply = 0;
const FREE_MAX_SUPPLY = 222;

// ===========================
// GLOBAL VARIABLES
// ===========================
let provider = null;
let signer = null;
let contract = null;
let freeContract = null;
let userAddress = null;

let isConnecting = false;
let isSwitchingNetwork = false;
let connectionAttempts = 0;
const MAX_CONNECTION_ATTEMPTS = 3;

// ===========================
// DEBUG LOGGING
// ===========================
function log(message, type = 'info', isFree = false) {
  const debugDiv = document.getElementById(isFree ? 'freeDebugInfo' : 'debugInfo');
  const logClass = type === 'error' ? 'debug-error' : type === 'success' ? 'debug-success' : 'debug-log';
  const timestamp = new Date().toLocaleTimeString();
  debugDiv.innerHTML += `<div class="${logClass}">[${timestamp}] ${message}</div>`;
  debugDiv.scrollTop = debugDiv.scrollHeight;
  console.log(`[${isFree ? 'FREE' : 'PAID'}] [${type.toUpperCase()}] ${message}`);
}

// ===========================
// WALLET CONNECTION (PAID)
// ===========================
async function connectWallet() {
  if (CONTRACT_ADDRESS === '0xYourContractAddressHere' || !CONTRACT_ADDRESS.startsWith('0x') || CONTRACT_ADDRESS.length !== 42) {
    log('‚ùå CONTRACT ADDRESS NOT CONFIGURED!', 'error');
    alert('Error: Contract address is not set!');
    return;
  }

  if (isConnecting) {
    log('Connection already in progress, please wait...', 'error');
    return;
  }

  if (connectionAttempts >= MAX_CONNECTION_ATTEMPTS) {
    log('Too many connection attempts. Please refresh the page.', 'error');
    alert('Too many connection attempts. Please refresh the page and try again.');
    return;
  }

  isConnecting = true;
  connectionAttempts++;

  try {
    log('Checking for MetaMask...');
    
    if (typeof window.ethereum === 'undefined') {
      throw new Error('MetaMask not installed! Please install MetaMask extension.');
    }

    log('MetaMask detected, requesting accounts...');
    
    const accounts = await window.ethereum.request({ 
      method: 'eth_requestAccounts' 
    });
    
    userAddress = accounts[0];
    log(`Connected: ${userAddress.substring(0, 6)}...${userAddress.substring(38)}`, 'success');

    const currentChainId = await window.ethereum.request({ method: 'eth_chainId' });
    log(`Current MetaMask network: ${currentChainId} (${parseInt(currentChainId, 16)})`);
    
    if (currentChainId.toLowerCase() !== HYPERLIQUID_CONFIG.chainId.toLowerCase()) {
      log(`Wrong network detected! Expected: ${HYPERLIQUID_CONFIG.chainId}, Got: ${currentChainId}`, 'error');
      log('Forcing network switch to Hyperliquid mainnet...', 'error');
      await switchToHyperliquid();
      
      await new Promise(resolve => setTimeout(resolve, 2000));
      
      const newChainId = await window.ethereum.request({ method: 'eth_chainId' });
      if (newChainId.toLowerCase() !== HYPERLIQUID_CONFIG.chainId.toLowerCase()) {
        throw new Error(`Network switch failed. Please manually switch to Hyperliquid mainnet (Chain ID: 999) in MetaMask.`);
      }
    }

    provider = new ethers.providers.Web3Provider(window.ethereum, {
      name: 'hyperliquid',
      chainId: parseInt(HYPERLIQUID_CONFIG.chainId, 16),
      ensAddress: null
    });
    signer = provider.getSigner();

    const network = await provider.getNetwork();
    log(`Provider network: ${network.name} (${network.chainId})`, 'success');

    log(`Initializing contract at ${CONTRACT_ADDRESS}...`);
    contract = new ethers.Contract(CONTRACT_ADDRESS, CONTRACT_ABI, signer);
    log('Contract initialized', 'success');

    updateButtonState('connected');
    await loadSupplyData();

    connectionAttempts = 0;

  } catch (error) {
    log(`Connection error: ${error.message}`, 'error');
    
    if (error.code === 4001) {
      alert('Connection cancelled by user');
    } 
    else if (error.message.includes('already pending')) {
      alert('Network change already in progress. Please check MetaMask and complete the action.');
    }
    else if (error.message.includes('Network switch failed')) {
      alert(error.message);
    }
    else {
      alert(`Connection failed: ${error.message}`);
    }
  } finally {
    isConnecting = false;
  }
}

// ===========================
// WALLET CONNECTION (FREE)
// ===========================
async function connectWalletFree() {
  if (FREE_CONTRACT_ADDRESS === '0xYourFreeContractAddressHere' || !FREE_CONTRACT_ADDRESS.startsWith('0x') || FREE_CONTRACT_ADDRESS.length !== 42) {
    log('‚ùå FREE CONTRACT ADDRESS NOT CONFIGURED!', 'error', true);
    alert('Error: Free mint contract address is not set!');
    return;
  }

  if (isConnecting) {
    log('Connection already in progress, please wait...', 'error', true);
    return;
  }

  if (connectionAttempts >= MAX_CONNECTION_ATTEMPTS) {
    log('Too many connection attempts. Please refresh the page.', 'error', true);
    alert('Too many connection attempts. Please refresh the page and try again.');
    return;
  }

  isConnecting = true;
  connectionAttempts++;

  try {
    log('Checking for MetaMask...', 'info', true);
    
    if (typeof window.ethereum === 'undefined') {
      throw new Error('MetaMask not installed! Please install MetaMask extension.');
    }

    log('MetaMask detected, requesting accounts...', 'info', true);
    
    const accounts = await window.ethereum.request({ 
      method: 'eth_requestAccounts' 
    });
    
    userAddress = accounts[0];
    log(`Connected: ${userAddress.substring(0, 6)}...${userAddress.substring(38)}`, 'success', true);

    const currentChainId = await window.ethereum.request({ method: 'eth_chainId' });
    log(`Current MetaMask network: ${currentChainId} (${parseInt(currentChainId, 16)})`, 'info', true);
    
    if (currentChainId.toLowerCase() !== HYPERLIQUID_CONFIG.chainId.toLowerCase()) {
      log(`Wrong network detected! Expected: ${HYPERLIQUID_CONFIG.chainId}, Got: ${currentChainId}`, 'error', true);
      log('Forcing network switch to Hyperliquid mainnet...', 'error', true);
      await switchToHyperliquid();
      
      await new Promise(resolve => setTimeout(resolve, 2000));
      
      const newChainId = await window.ethereum.request({ method: 'eth_chainId' });
      if (newChainId.toLowerCase() !== HYPERLIQUID_CONFIG.chainId.toLowerCase()) {
        throw new Error(`Network switch failed. Please manually switch to Hyperliquid mainnet (Chain ID: 999) in MetaMask.`);
      }
    }

    provider = new ethers.providers.Web3Provider(window.ethereum, {
      name: 'hyperliquid',
      chainId: parseInt(HYPERLIQUID_CONFIG.chainId, 16),
      ensAddress: null
    });
    signer = provider.getSigner();

    const network = await provider.getNetwork();
    log(`Provider network: ${network.name} (${network.chainId})`, 'success', true);

    log(`Initializing free contract at ${FREE_CONTRACT_ADDRESS}...`, 'info', true);
    freeContract = new ethers.Contract(FREE_CONTRACT_ADDRESS, FREE_CONTRACT_ABI, signer);
    log('Free contract initialized', 'success', true);

    updateButtonState('connected', true);
    await loadSupplyData(true);

    connectionAttempts = 0;

  } catch (error) {
    log(`Connection error: ${error.message}`, 'error', true);
    
    if (error.code === 4001) {
      alert('Connection cancelled by user');
    } 
    else if (error.message.includes('already pending')) {
      alert('Network change already in progress. Please check MetaMask and complete the action.');
    }
    else if (error.message.includes('Network switch failed')) {
      alert(error.message);
    }
    else {
      alert(`Connection failed: ${error.message}`);
    }
  } finally {
    isConnecting = false;
  }
}

// ===========================
// NETWORK SWITCHING
// ===========================
async function switchToHyperliquid() {
  if (isSwitchingNetwork) {
    log('Network switch already in progress...', 'error');
    throw new Error('Network switch already in progress. Please complete it in MetaMask.');
  }

  isSwitchingNetwork = true;

  try {
    await window.ethereum.request({
      method: 'wallet_switchEthereumChain',
      params: [{ chainId: HYPERLIQUID_CONFIG.chainId }],
    });
    log('Switched to Hyperliquid!', 'success');
    
  } catch (switchError) {
    if (switchError.code === 4902) {
      log('Hyperliquid not found, adding network...');
      
      await new Promise(resolve => setTimeout(resolve, 500));
      
      try {
        await window.ethereum.request({
          method: 'wallet_addEthereumChain',
          params: [{
            chainId: HYPERLIQUID_CONFIG.chainId,
            chainName: HYPERLIQUID_CONFIG.chainName,
            rpcUrls: HYPERLIQUID_CONFIG.rpcUrls,
            nativeCurrency: HYPERLIQUID_CONFIG.nativeCurrency,
            blockExplorerUrls: HYPERLIQUID_CONFIG.blockExplorerUrls
          }]
        });
        log('Hyperliquid network added!', 'success');
      } catch (addError) {
        if (addError.message && addError.message.includes('already pending')) {
          log('Network add request already pending in MetaMask', 'error');
          throw new Error('Please complete the network addition in MetaMask popup');
        }
        throw new Error(`Failed to add Hyperliquid network: ${addError.message}`);
      }
    } 
    else if (switchError.code === 4001) {
      throw new Error('Network switch cancelled by user');
    }
    else if (switchError.message && switchError.message.includes('already pending')) {
      throw new Error('Network switch already pending. Please check MetaMask.');
    }
    else {
      throw switchError;
    }
  } finally {
    isSwitchingNetwork = false;
  }
}

// ===========================
// SUPPLY DATA
// ===========================
async function loadSupplyData(isFree = false) {
  const minted = isFree ? freeCurrentMintedSupply : currentMintedSupply;
  const max = isFree ? FREE_MAX_SUPPLY : MAX_SUPPLY;
  const percentage = (minted / max) * 100;
  
  const countId = isFree ? 'freeSupplyCount' : 'supplyCount';
  const fillId = isFree ? 'freeProgressFill' : 'progressFill';
  const textId = isFree ? 'freeProgressText' : 'progressText';
  
  document.getElementById(countId).textContent = `${minted} / ${max}`;
  document.getElementById(fillId).style.width = `${percentage}%`;
  document.getElementById(textId).textContent = `${percentage.toFixed(1)}% minted`;
  
  log(`Supply: ${minted}/${max} (${percentage.toFixed(1)}%)`, 'success', isFree);
  
  try {
    let readContract = isFree ? freeContract : contract;
    
    if (!readContract) {
      const readProvider = new ethers.providers.JsonRpcProvider(HYPERLIQUID_CONFIG.rpcUrls[0]);
      const addr = isFree ? FREE_CONTRACT_ADDRESS : CONTRACT_ADDRESS;
      const abi = isFree ? FREE_CONTRACT_ABI : CONTRACT_ABI;
      readContract = new ethers.Contract(addr, abi, readProvider);
    }
    
    try {
      const counter = await readContract._tokenIdCounter();
      const contractCount = counter.toNumber();
      if (contractCount > 0) {
        if (isFree) {
          freeCurrentMintedSupply = contractCount;
        } else {
          currentMintedSupply = contractCount;
        }
        log(`‚úÖ Contract counter: ${contractCount}`, 'success', isFree);
        const newPercentage = (contractCount / max) * 100;
        document.getElementById(countId).textContent = `${contractCount} / ${max}`;
        document.getElementById(fillId).style.width = `${newPercentage}%`;
        document.getElementById(textId).textContent = `${newPercentage.toFixed(1)}% minted`;
      }
    } catch (e) {
      // Silently ignore
    }
    
  } catch (error) {
    // Silently ignore
  }
}

// ===========================
// MINTING (PAID)
// ===========================
async function mintNFT() {
  if (!contract || !signer) {
    log('Wallet not connected!', 'error');
    return;
  }

  try {
    log('Starting mint transaction...', 'success');
    updateButtonState('minting');

    const gasEstimate = await contract.estimateGas.mint({ value: MINT_PRICE });
    log(`Estimated gas: ${gasEstimate.toString()}`);

    const tx = await contract.mint({ 
      value: MINT_PRICE,
      gasLimit: gasEstimate.mul(120).div(100)
    });

    log(`Transaction sent: ${tx.hash}`, 'success');
    log('‚è≥ Waiting for confirmation...', 'success');

    const receipt = await tx.wait();
    
    log(`‚úÖ MINTED SUCCESSFULLY! Block: ${receipt.blockNumber}`, 'success');
    log(`‚úÖ Transaction: https://purrsec.com/tx/${tx.hash}`, 'success');

    currentMintedSupply++;
    log(`üî• Supply updated: ${currentMintedSupply}/${MAX_SUPPLY}`, 'success');
    
    await loadSupplyData();
    
    updateButtonState('connected');
    
    const shortHash = tx.hash.substring(0, 10) + '...';
    alert(`üéâ NFT SUCCESSFULLY MINTED!\n\nTransaction: ${shortHash}`);
    
    log('‚úÖ Minting complete!', 'success');

  } catch (error) {
    log(`‚ùå Mint failed: ${error.message}`, 'error');
    
    if (error.code === 4001 || error.code === 'ACTION_REJECTED') {
      log('User cancelled transaction', 'error');
      alert('Transaction cancelled by user');
    } else if (error.message.includes('insufficient funds')) {
      log('Insufficient HYPE balance', 'error');
      alert('Insufficient HYPE balance. You need 0.1 HYPE + gas fees.');
    } else if (error.message.includes('Sold out')) {
      log('NFT collection sold out!', 'error');
      alert('Sorry, all NFTs have been minted!');
    } else {
      alert(`Minting failed: ${error.message}`);
    }
    
    updateButtonState('connected');
  }
}

// ===========================
// MINTING (FREE)
// ===========================
async function mintNFTFree() {
  if (!freeContract || !signer) {
    log('Wallet not connected!', 'error', true);
    return;
  }

  try {
    log('Starting free mint transaction...', 'success', true);
    updateButtonState('minting', true);

    const gasEstimate = await freeContract.estimateGas.mint({ value: FREE_MINT_PRICE });
    log(`Estimated gas: ${gasEstimate.toString()}`, 'info', true);

    const tx = await freeContract.mint({ 
      value: FREE_MINT_PRICE,
      gasLimit: gasEstimate.mul(120).div(100)
    });

    log(`Transaction sent: ${tx.hash}`, 'success', true);
    log('‚è≥ Waiting for confirmation...', 'success', true);

    const receipt = await tx.wait();
    
    log(`‚úÖ FREE MINTED SUCCESSFULLY! Block: ${receipt.blockNumber}`, 'success', true);
    log(`‚úÖ Transaction: https://purrsec.com/tx/${tx.hash}`, 'success', true);

    freeCurrentMintedSupply++;
    log(`üî• Free supply updated: ${freeCurrentMintedSupply}/${FREE_MAX_SUPPLY}`, 'success', true);
    
    await loadSupplyData(true);
    
    updateButtonState('connected', true);
    
    const shortHash = tx.hash.substring(0, 10) + '...';
    alert(`üéâ FREE NFT SUCCESSFULLY MINTED!\n\nTransaction: ${shortHash}`);
    
    log('‚úÖ Free minting complete!', 'success', true);

  } catch (error) {
    log(`‚ùå Free mint failed: ${error.message}`, 'error', true);
    
    if (error.code === 4001 || error.code === 'ACTION_REJECTED') {
      log('User cancelled transaction', 'error', true);
      alert('Transaction cancelled by user');
    } else if (error.message.includes('insufficient funds')) {
      log('Insufficient HYPE for gas', 'error', true);
      alert('Insufficient HYPE for gas fees.');
    } else if (error.message.includes('Sold out')) {
      log('Free NFT collection sold out!', 'error', true);
      alert('Sorry, all free NFTs have been minted!');
    } else if (error.message.includes('Max per wallet')) {
      log('Maximum per wallet reached', 'error', true);
      alert('You have reached the maximum mint limit (10 NFTs per wallet)');
    } else {
      alert(`Free minting failed: ${error.message}`);
    }
    
    updateButtonState('connected', true);
  }
}

// ===========================
// BUTTON STATE MANAGEMENT
// ===========================
function updateButtonState(state, isFree = false) {
  const button = document.getElementById(isFree ? 'freeMintButton' : 'mintButton');
  
  switch(state) {
    case 'connected':
      button.textContent = isFree ? 'üéÅ Mint Free (0 HYPE)' : 'üî• Mint Now (0.1 HYPE)';
      button.disabled = false;
      button.onclick = isFree ? mintNFTFree : mintNFT;
      break;
    case 'minting':
      button.textContent = '‚è≥ Minting...';
      button.disabled = true;
      break;
    default:
      button.textContent = 'Connect Wallet';
      button.disabled = false;
      button.onclick = isFree ? connectWalletFree : connectWallet;
  }
}

// ===========================
// EVENT LISTENERS
// ===========================
document.getElementById('mintButton').addEventListener('click', connectWallet);
document.getElementById('freeMintButton').addEventListener('click', connectWalletFree);

if (window.ethereum) {
  window.ethereum.on('chainChanged', (chainId) => {
    log(`Network changed to: ${chainId}`, 'error');
    if (chainId === HYPERLIQUID_CONFIG.chainId) {
      log('Correct network detected, reloading...', 'success');
      setTimeout(() => window.location.reload(), 1000);
    } else {
      log('Wrong network! Please switch to Hyperliquid mainnet (Chain ID: 999)', 'error');
      alert('Wrong network detected. Please switch to Hyperliquid mainnet in MetaMask.');
    }
  });

  window.ethereum.on('accountsChanged', (accounts) => {
    if (accounts.length === 0) {
      log('Wallet disconnected', 'error');
      updateButtonState('disconnected');
      updateButtonState('disconnected', true);
    } else {
      log('Account changed, reloading...', 'error');
      setTimeout(() => window.location.reload(), 500);
    }
  });
}

// ===========================
// INITIAL LOAD
// ===========================
window.addEventListener('load', () => {
  log('Page loaded, ready to connect wallet');
  log('Page loaded, ready to connect wallet', 'info', true);
  
  if (typeof window.ethereum !== 'undefined') {
    log('MetaMask extension detected', 'success');
    log('MetaMask extension detected', 'success', true);
  } else {
    log('MetaMask not installed', 'error');
    log('MetaMask not installed', 'error', true);
  }
  
  loadSupplyData();
  loadSupplyData(true);
  
  setInterval(async () => {
    log('üîÑ Auto-refreshing supply...', 'success');
    await loadSupplyData();
    await loadSupplyData(true);
  }, 3000);
});
</script>

</body>
</html>
