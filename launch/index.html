<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>CatKitSune ‚Äì Free Mint</title>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&display=swap" rel="stylesheet">
<script src="https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.umd.min.js"></script>
<style>
body {
  font-family: Inter, sans-serif;
  background: linear-gradient(135deg,#0f766e,#042f2e);
  min-height: 100vh;
  display:flex;
  align-items:center;
  justify-content:center;
  color:white;
}
.card {
  background:#022c22;
  padding:40px;
  border-radius:20px;
  max-width:420px;
  width:100%;
  text-align:center;
  box-shadow:0 20px 60px rgba(0,0,0,.4);
}
h1 { font-size:28px; margin-bottom:10px; }
p { opacity:.85; margin-bottom:30px; }
button {
  width:100%;
  padding:18px;
  font-size:18px;
  font-weight:800;
  border:none;
  border-radius:14px;
  background:linear-gradient(135deg,#14b8a6,#0d9488);
  color:white;
  cursor:pointer;
  transition: all 0.3s;
}
button:hover:not(:disabled) {
  transform: translateY(-2px);
  box-shadow: 0 10px 30px rgba(20,184,166,0.3);
}
button:disabled {
  opacity:.6;
  cursor:not-allowed;
}
.status {
  margin-top:20px;
  font-size:14px;
  min-height:20px;
  line-height:1.6;
}
.error { color:#fca5a5; }
.success { color:#86efac; }
</style>
</head>
<body>
<div class="card">
  <h1>üê± CatKitSune</h1>
  <p>Mint 1 NFT for FREE<br>0 HYPE ¬∑ Test mint</p>
  <button id="mintBtn" onclick="mint()">Connect & Mint</button>
  <div class="status" id="status"></div>
</div>
<script>
/* ================= CONFIG ================= */
const CONTRACT_ADDRESS = "0xf64D89F2DD7E26C4b4555F03b556428F1EBe9598";
const HYPEREVM_CHAIN_ID = "0x3e7"; // 999
const ABI = [
  "function publicMint(uint256 quantity) payable",
  "function totalSupply() view returns (uint256)",
  "function maxSupply() view returns (uint256)",
  "function owner() view returns (address)"
];

/* ================= LOGIC ================= */
const statusEl = document.getElementById("status");
const btn = document.getElementById("mintBtn");

function setStatus(msg, type = "info") {
  statusEl.className = `status ${type}`;
  statusEl.innerHTML = msg;
  console.log(msg);
}

async function mint() {
  try {
    if (!window.ethereum) {
      alert("‚ùå MetaMask not detected!\n\nPlease install MetaMask extension.");
      return;
    }

    btn.disabled = true;
    setStatus("üîå Connecting wallet...");
    
    await window.ethereum.request({ method: "eth_requestAccounts" });
    
    const chainId = await window.ethereum.request({ method: "eth_chainId" });
    
    // üëâ NETWORK SWITCH
    if (chainId !== HYPEREVM_CHAIN_ID) {
      setStatus("üîÑ Switching to HyperEVM...");
      try {
        await window.ethereum.request({
          method: "wallet_switchEthereumChain",
          params: [{ chainId: HYPEREVM_CHAIN_ID }]
        });
        // Kis delay a network switch ut√°n
        await new Promise(resolve => setTimeout(resolve, 1500));
      } catch (switchError) {
        if (switchError.code === 4902) {
          alert("‚ùå HyperEVM network not found!\n\nPlease add HyperEVM to MetaMask first.");
          setStatus("Network not configured", "error");
          btn.disabled = false;
          return;
        }
        throw switchError;
      }
    }

    // üî• PROVIDER CSAK SWITCH UT√ÅN
    const provider = new ethers.providers.Web3Provider(window.ethereum);
    const signer = provider.getSigner();
    const userAddress = await signer.getAddress();
    
    setStatus(`üë§ Connected: ${userAddress.slice(0,6)}...${userAddress.slice(-4)}`);

    // ‚úÖ CHECK CONTRACT EXISTS
    setStatus("üîç Checking contract...");
    const code = await provider.getCode(CONTRACT_ADDRESS);
    
    if (code === "0x") {
      setStatus(`‚ùå Contract not deployed!<br><br>Address: ${CONTRACT_ADDRESS}<br><br>Make sure you deployed the contract to HyperEVM testnet.`, "error");
      btn.disabled = false;
      return;
    }

    const contract = new ethers.Contract(CONTRACT_ADDRESS, ABI, signer);

    // ‚úÖ TRY TO READ CONTRACT DATA
    try {
      setStatus("üìä Reading contract data...");
      const [totalSupply, maxSupply] = await Promise.all([
        contract.totalSupply().catch(() => ethers.BigNumber.from(0)),
        contract.maxSupply().catch(() => ethers.BigNumber.from(0))
      ]);
      
      if (maxSupply.gt(0)) {
        setStatus(`üìä Supply: ${totalSupply}/${maxSupply}`);
        
        if (totalSupply.gte(maxSupply)) {
          setStatus("‚ùå Max supply reached!", "error");
          btn.disabled = false;
          return;
        }
      }
    } catch (e) {
      console.warn("Could not read supply:", e);
    }

    // ‚úÖ ATTEMPT MINT
    setStatus("‚õèÔ∏è Preparing transaction...");
    
    const tx = await contract.publicMint(1, { 
      value: ethers.utils.parseEther("0"),
      gasLimit: 500000 // Explicit gas limit
    });

    setStatus("‚è≥ Waiting for confirmation...");
    const receipt = await tx.wait();

    setStatus(`‚úÖ NFT Minted Successfully!<br><br>Tx: ${receipt.transactionHash.slice(0,10)}...`, "success");
    
    setTimeout(() => {
      alert("üéâ SUCCESS!\n\nYour NFT has been minted!");
    }, 500);

  } catch (err) {
    console.error("Mint error:", err);
    
    let errorMsg = "‚ùå Mint failed";
    
    if (err.code === "UNPREDICTABLE_GAS_LIMIT") {
      errorMsg = `‚ùå Transaction would fail!<br><br>Possible reasons:<br>‚Ä¢ Contract not properly deployed<br>‚Ä¢ Minting n
